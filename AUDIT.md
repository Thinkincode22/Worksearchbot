# Аудит проекту WorkSearchBot

**Дата:** 30 січня 2025  
**Версія проекту:** 1.0.0

---

## 1. Загальна оцінка

| Категорія        | Оцінка | Коментар |
|------------------|--------|----------|
| Архітектура      | 4/5    | Чітка структура, розділення відповідальностей |
| Код              | 3.5/5  | Є баги та неконсистентності |
| Безпека          | 3/5    | Базові речі є, rate limiting не реалізовано |
| Тестування       | 1/5    | Тестів немає |
| Документація     | 4/5    | README, PLAN, SETUP присутні |
| Деплой/CI        | 3/5    | Є workflow, але слабкий |

---

## 2. Критичні проблеми

### 2.1 Помилка при виклику команд (CRITICAL)

**Файли:** `bot/handlers/search.py`, `filters.py`, `favorites.py`, `subscriptions.py`, `stats.py`

**Проблема:** При виклику команд `/search`, `/filters`, `/favorites`, `/subscriptions`, `/stats` через Telegram (не через кнопки) використовується `query = update.callback_query or update.message`. Далі викликається `await query.answer()`, але об'єкт `Message` не має методу `answer()` — він є лише у `CallbackQuery`. Це призводить до **AttributeError** при кожному виклику цих команд.

**Рішення:** Викликати `query.answer()` лише коли `update.callback_query` не None:

```python
if update.callback_query:
    await update.callback_query.answer()
```

### 2.2 Дублювання виклику `query.answer()` у favorite_callback_handler

**Файл:** `bot/handlers/favorites.py`

**Проблема:** На початку `favorite_callback_handler` викликається `await query.answer()`, а потім у блоці `if not db_user` знову `await query.answer("Помилка...")`. Другий виклик `answer()` для того самого callback не потрібен і може спричинити попередження/помилку від Telegram API (callback вже відповіло).

**Рішення:** Після першого `answer()` при помилці використовувати лише `return`, без повторного `answer()`.

### 2.3 Скрапер OLX: синхронний код в async scheduler

**Файли:** `scraper/scheduler.py`, `scraper/scrapers/olx_scraper.py`

**Проблема:** `scrape_source` оголошена як `async`, але всередині викликається синхронний `scraper.fetch_jobs()` та `scraper.parse_job()`. Це блокує event loop на час парсингу (HTTP-запити, парсинг HTML). При великій кількості вакансій бот може «зависати».

**Рішення:** Виконувати скрапінг у thread pool: `await asyncio.to_thread(scraper.fetch_jobs, max_pages=3)` або винести скрапінг у окремий процес/чергу.

---

## 3. Важливі проблеми

### 3.1 Відсутня папка міграцій Alembic

**Шлях:** `database/migrations/versions/`

**Проблема:** Є `env.py` та `script.py.mako`, але немає папки `versions/` і жодного файлу ревізій. Таблиці створюються через `Base.metadata.create_all()` при старті, тому міграції фактично не використовуються. При зміні моделей немає історії змін БД.

**Рішення:** Виконати `alembic revision --autogenerate -m "initial"` для створення початкової міграції та додати папку `versions/` у репозиторій.

### 3.2 Шаблон Alembic script.py.mako

**Файл:** `database/migrations/script.py.mako`

**Проблема:** У шаблоні використовуються змінні `branch_labels` та `depends_on`, які при ручній генерації ревізій можуть бути не визначені, що призведе до помилки Mako.

**Рішення:** Використовувати умовний вивід або прибрати ці поля, якщо гілки не використовуються:

```mako
branch_labels = ${repr(branch_labels) if 'branch_labels' in dir() else 'None'}
depends_on = ${repr(depends_on) if 'depends_on' in dir() else 'None'}
```

Або використати стандартний шаблон Alembic без цих полів.

### 3.3 Міграції env.py: можливий None від get_section

**Файл:** `database/migrations/env.py`

**Проблема:** `config.get_section(config.config_ini_section)` може повернути `None`, тоді присвоєння `configuration["sqlalchemy.url"] = get_url()` викличе TypeError.

**Рішення:**

```python
configuration = config.get_section(config.config_ini_section) or {}
configuration["sqlalchemy.url"] = get_url()
```

### 3.4 Глобальний стан пошуку в пам'яті

**Файл:** `bot/handlers/search.py`

**Проблема:** `user_search_state = {}` зберігає результати пошуку та фільтри в пам'яті процесу. При перезапуску бота стан губиться. При деплої на кілька інстансів стан не спільний. Немає обмеження розміру словника — можливе витік пам'яті при великій кількості користувачів.

**Рішення:** Обмежити кількість записів (наприклад, LRU), або перенести тимчасовий стан у Redis/БД.

### 3.5 Форматування вакансії: XSS та довжина повідомлення

**Файл:** `bot/utils/formatters.py`

**Проблеми:**

- Текст з БД (title, company, description тощо) вставляється в HTML без екранування. Якщо в оголошенні є символи `<`, `>`, `&`, Telegram може некоректно відобразити повідомлення або це створить ризик injection.
- Повідомлення в Telegram обмежені 4096 символами. Якщо опис дуже довгий, повідомлення може обрізатися або API поверне помилку.

**Рішення:** Екранувати HTML (`html.escape`) для полів з контентом і обрізати загальну довжину повідомлення до 4000 символів.

### 3.6 Довільний текст сприймається як пошуковий запит

**Файл:** `main.py` — `MessageHandler(filters.TEXT & ~filters.COMMAND, search_query_handler)`

**Проблема:** Будь-яке текстове повідомлення, що не є командою, спрямовується в пошук. Користувач не може просто написати щось у чат (наприклад, відповідь боту) без запуску пошуку. Немає «режиму очікування» (наприклад, після натискання «Введіть зарплату») — введене число також піде в пошук.

**Рішення:** Ввести ConversationHandler або зберігати в `context.user_data` стан (наприклад, «очікуємо зарплату») і обробляти текст залежно від стану; інакше — явно просити використовувати команду /search перед пошуком.

---

## 4. Рекомендації (низький пріоритет)

### 4.1 Конфігурація Settings

**Файл:** `config/settings.py`

- Використовується одночасно `BaseSettings` і `os.getenv()`. Pydantic сам читає `.env` при `env_file=".env"`, тому дублювання з `os.getenv()` зайве.
- `SCRAPING_INTERVAL_MINUTES` при невалідному значенні в env викличе `ValueError` — краще обробляти виняток або валідувати через Pydantic.

### 4.2 Голі except

**Файли:** `scraper/base_scraper.py`, `bot/utils/formatters.py`

- Використовується `except:` або `except Exception` без логування або повторного викидання. Це ховає помилки.
- Краще: логувати і або перевикидати, або повертати безпечне значення за замовчуванням.

### 4.3 Логування

- У `database/database.py` використовується `print("База даних ініціалізована успішно!")`. Краще використовувати `logging`/`loguru` для уніфікації логів.

### 4.4 Типізація

- У сигнатурах частини функцій відсутні типи (наприклад, `format_subscription_info(subscription)`). Додати типи для моделей і аргументів покращить підтримку та автодоповнення.

### 4.5 Rate limiting

- У `config/settings.py` є `MAX_REQUESTS_PER_MINUTE` та `MAX_REQUESTS_PER_HOUR`, але в коді бота вони не використовуються. Є ризик спаму та зловживань.

### 4.6 Тести

- Немає жодного тесту (`tests/` порожня або відсутня). У `requirements.txt` є pytest та pytest-asyncio, але вони не використовуються.
- Рекомендація: додати хоча б unit-тести для formatters, validators, та інтеграційні для ключових handlers.

### 4.7 CI

**Файл:** `.github/workflows/syntax-check.yml`

- Використовується `actions/setup-python@v2` — зараз актуальніша версія v5.
- `python -m py_compile ... || true` — помилки компіляції ігноруються через `|| true`, тобто збій не провалить пайплайн.
- Немає кроків: lint (ruff/flake8), type check (mypy), тести.

### 4.8 Залежності

- Зафіксовані версії в `requirements.txt` — це добре для відтворюваності.
- `psycopg2-binary` зручний для розробки, але для продакшену часто рекомендують `psycopg2` (збирати з пакету). Стоїть коментар «або sqlite3» — варто явно вказати в README/SETUP, що для продакшену краще PostgreSQL.

### 4.9 Middleware

**Файл:** `bot/middlewares/user_middleware.py`

- Клас `UserMiddleware` реалізований, але в `main.py` він не підключений до `Application`, тому реєстрація користувачів відбувається лише в `start_handler`. Якщо потрібна реєстрація при будь-якій взаємодії — middleware треба додати.

### 4.10 Підписки

- Функціонал підписок оголошений у плані, але в `subscriptions_handler` лише показ списку; створення/редагування/видалення підписок та відправка сповіщень не реалізовані. У `subscription_callback_handler` зараз заглушка «в розробці».

---

## 5. Позитивні сторони

- Зрозуміла структура проекту (bot, scraper, database, config).
- Використання контекстного менеджера `get_db_session()` для коректного закриття сесій БД.
- Єдина точка конфігурації через `config/settings.py` та константи.
- Клавіатури винесені в окремі модулі, зручно підтримувати.
- Базовий скрапер з retry та нормалізацією даних; OLX винесений в окремий клас.
- Документація: README, PLAN, SETUP, DEPLOY дають достатньо інформації для запуску та розуміння проекту.

---

## 6. План дій (пріоритети)

| Пріоритет | Дія |
|-----------|-----|
| P0 | Виправити виклик `query.answer()` в handlers (лише для callback_query). |
| P0 | У `favorite_callback_handler` не викликати `answer()` двічі. |
| P1 | Додати екранування HTML у formatters та обмеження довжини повідомлення. |
| P1 | Не блокувати event loop: скрапінг у thread/process або через asyncio.to_thread. |
| P1 | Обмежити/перенести `user_search_state` (LRU або Redis). |
| P2 | Додати початкову міграцію Alembic та виправити env.py/script.py.mako. |
| P2 | Реалізувати простий rate limiting для користувачів. |
| P2 | Додати базові unit-тести та покращити CI (lint, tests без `|| true`). |
| P3 | ConversationHandler або стани для введення зарплати/ключових слів. |
| P3 | Доробити підписки та сповіщення. |

---

*Аудит підготував автоматизований аналіз кодової бази. Рекомендується пройтися по пунктах P0–P1 перед використанням бота в продакшені.*
